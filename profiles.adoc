= RISC-V Profiles
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:toc-title: Version 0.1-draft. Current State: Discussion Document. Assume everything can change. This document is not complete yet and was created only for the purpose of conversation outside of the document. https://riscv.org/spec-state.
:numbered:
:stem: latexmath
:le: &#8804;
:ge: &#8805;
:ne: &#8800;
:approx: &#8776;
:inf: &#8734;

:sectnums!:

== Status

*This is only an initial proposal and is likely to change substantially if it is standardized.*

:sectnums:

== Introduction

RISC-V was designed to provide a highly modular and extensible
instruction set, and includes a large and growing set of standard and
custom extensions.  This flexibility can be used to highly optimize a
specialized design by including only the exact set of ISA features
required for an application, but the same flexibility also leads to a
potential combinatorial explosion in possible ISA choices.  Another
pragmatic concern is the long and unwieldy ISA strings required to
encode common sets of extensions, which will continue to grow as new
extensions are defined.

Many application areas depend on a rich software ecosystem, which is
only made possible by reducing the possible combinations of ISA
features that the software ecosystem has to support.  Architecture
profiles are intended to provide a structure for describing these
commonly used combinations of instruction set extensions within broad
application domains.  Profiles provide a convenient shorthand for
describing the ISA portions of hardware and software platforms, and
also guide the development of software toolchains common to different
platforms that share the same profile.

As RISC-V evolves over time, the set of ISA features supported by each
platform will also want to evolve over time.  Also, new platforms may
be added over time with their own ISA requirements.  To help manage
this evolution, RISC-V is moving towards a model of regular annual
delivery of a coherent set of ISA updates according to an ISA roadmap,
and architecture profiles are intended to provide the natural
structure for planning, packaging, and releasing these ISA updates.

The architecture profiles will also be used for branding and to
advertise compatibility with the RISC-V standard.

Profiles are not intended to replace or prohibit the use of
combinations of individual ISA extensions, which can continue to be
used for more specialized applications.

This document describes the general structure of RISC-V architecture
profiles and also the specifics of the first two families of
architecture profiles for application processors: RVA20 and RVA22.

NOTE: Other profiles are under development: RVI20 for basic RISC-V
unprivileged software compatibility, and RVM20 and RVM22 for
microcontroller platforms and these will be added in a future version
of this document.

== Profiles versus Platforms

Profiles only describe ISA features, not a complete execution
environment.

A _software_ _platform_ is a specification for an execution
environment, in which software targeted for that platform can run.

NOTE: A user-level ABI under a Unix-like OS defines a software
platform for unprivileged code execution.  The supervisor-level RISC-V
SBI defines a software platform to run privileged code.

A _hardware_ _platform_ is a specification for hardware systems (which
can be viewed as physical realizations of an execution environment).

NOTE: Most hardware platforms have a defined boot mechanism, which can
configure and initialize an instance of a software platform (e.g.,
Linux) on the hardware platform (e.g., a server).

Both software and hardware platforms include specifications for many
features beyond details of the ISA used by RISC-V processors in the
platform (e.g., behavior of environment calls in a software platform
or location of memory regions in a hardware platform).  Architecture
profiles factor out ISA-specific definitions from platform
definitions, to allow ISA profiles to be reused across different
platforms, and to be used by tools (e.g., compilers) that are common
across many different platforms.

A platform can add additional constraints on top of those in a
profile.  For example, mandating an extension that is optional in the
underlying profile, or constraining some implementation-specific
parameter in the profile to lie within a certain range.

A platform cannot remove constraints from a profile.

NOTE: A new profile should be proposed if existing profiles do not
match the needs of a new platform.

== Components of a Profile

=== Profile Family

Every profile is a member of a _profile_ _family_.  A profile family
is a set of profiles that are designed for the same applications but
vary in base ISA and privilege mode.  The initial three families are:

- generic unprivileged instructions (I)
- microcontrollers for embedded systems (M)
- application processors running rich operating systems (A)

A family may be updated no more than annually, and the release
calendar year is treated as part of the family name.

More families may be added over time.

Each family is described in more detail below.

=== Base and Extensions

An architecture profile has a mandatory base instruction set (RV32I or
RV64I).  In addition, the profile categorizes all available ISA
extensions into four categories:

. Mandatory
. Supported Optional
. Unsupported Optional
. Incompatible

As the name implies, _Mandatory_ ISA extensions are a required part of
the profile.  Implementations of the profile must provide these, and
software using the profile can assume they exist.

_Supported_ _Optional_ extensions are those that are optional, but
which are expected to be generally supported by the software ecosystem
for this profile.

NOTE: The level of support for Supported Optional extension will
likely vary greatly among different software components supporting a
profile, but at the bare minimum tools or runtimes that are claiming
compatibility with the profile must not report errors or warnings if
supported optional extensions are present.

_Unsupported_ _Optional_ extensions are those that are optional, but
which are not expected to be generally supported by the software
ecosystem.

NOTE: Software components claiming compatibility with the profile are
not expected to be able to support these extensions, and may error or
report warnings if they are present.

_Incompatible_ extensions are those that conflict with the base or
optional extensions.  Software can assume these extensions are not
present.

All components of a ratified profile must themselves have been
ratified.

NOTE: Extensions that are ratified after a profile is released are
effectively either Unsupported Optional or Incompatible for that
profile.  A later release of a profile may include the feature as
Mandatory or Supported Optional.

Platforms may provide a discovery mechanism to determine what optional
extensions are present.

=== Profile Privilege Mode

In general, available instructions vary by privilege mode, and the
behavior of RISC-V instructions can depend on the active privilege
mode.

Separate profiles are provided for unprivileged code and each
privileged mode of each base ISA in a profile family.  Unprivileged
profiles include only unprivileged ISA features.  Privileged-mode
profiles include the behavior of instructions running in all
lower-privilege modes as well as the mode after which the profile is
named.

For example, the RVM20U32 profile would specify that an ECALL
instruction causes a requested trap to the execution environment.  The
details of how the requested trap is handled by the execution
environment are not specified by the profile as these are out of
scope.

NOTE: A software platform for RVM20U32 could detail what ECALLs are
supported by the execution environment defined by the platform.

In contrast, the RVM20S32 profile would specify that an ECALL in user
mode would cause a contained trap into supervisor mode, with the
trapping context state saved in supervisor-accessible CSRs.  However,
an ECALL in supervisor mode of an RVM20S32 profile would be specified
as a requested trap to the enclosing execution environment, and the
RVM20S32 profile would not specify how the requested trap is handled.

NOTE: A profile for a given privilege mode does not restrict whether
invisible traps to a more privileged mode are used to emulate profile
features.  In general, a profile can be implemented by an execution
environment using any hardware or software technique that provides
compatible functionality, up and including pure software emulation.

=== Profile Naming Convention

A profile name is a string comprised of, in order:

. prefix RV for RISC-V
. a specific profile family string (I, M, or A)
. a numeric string giving the first complete calendar year for which
the profile is ratified, represented as number of years after year
2000 (i.e., 20 for profiles built on specifications ratified during 2019)
. a privilege mode (U, S, M)
. a base ISA specifier (32, 64)

The initial profiles based on specifications ratified in 2019 are:

- RVI20U32 basic unprivileged instructions for RV32I
- RVI20U64 basic unprivileged instructions for RV64I
- RVM20U32, RVM20S32, RVM20M32 profiles for microcontrollers based on RV32I
- RVM20U64, RVM20S64, RVM20M64 profiles for microcontrollers based on RV64I
- RVA20U32, RVA20S32, RVA20M32 32-bit application-processor profiles
- RVA20U64, RVA20S64, RVA20M64 64-bit application-processor profiles

== RVA20 Profiles

The RVA20 family of profiles are intended to be used for application
processors running rich OS stacks.

NOTE: Only 64-bit profiles are shown here, but the eventual intent is to
define very similar 32-bit variants.

=== RVA20U64 Profile

The RVA20U64 profile represents the behavior of unprivileged code in
64-bit applications processors.  This is the most important profile
within the application processor family in terms of the amount of
software that targets this profile.

==== RVA20U64 Mandatory Extensions

- M
- A
- F
- D
- C
- Zicsr
- Zicntr
- Zihpm
- Misaligned loads and stores to main memory regions with both the
  cacheability and coherence PMAs must be supported.
- Main memory regions with both the cacheability and coherence PMAs must
  support instruction fetch, AMOArithmetic, and RsrvEventual.
- Reservation sets must be contiguous and at least 16 bytes and at most 128 bytes in size.
- Implementations are strongly recommended to raise illegal-instruction
  exceptions when attempting to execute unimplemented opcodes.

NOTE: Even when supported, misaligned loads and stores might execute
extremely slowly.  Standard software distributions should assume their
existence only for correctness, not for performance.

==== RVA20U64 Supported Optional Extensions

None.

==== RVA20U64 Unsupported Optional Extensions

- Q
- Zifencei

NOTE: The execution environment must provide a means to synchronize writes to
instruction memory with instruction fetches, the implementation of which
likely relies on the Zifencei extension.
For example, RISC-V Linux supplies the `__riscv_flush_icache` system call and
a corresponding vDSO call.

NOTE: Zifencei is not mandated because it is not sufficient by itself
to produce the desired effect in a multiprogrammed multiprocessor
environment without OS support, and so the instruction cache flush
should always be performed using an OS call.  The Zifencei semantics
can be expensive to implement for some hardware memory hierarchy
designs, and so alternative non-standard instruction-cache coherence
mechanisms can be used behind the OS abstraction.  A separate
extension is being developed for more general and efficient
instruction cache coherence.

==== RVA20U64 Incompatible Extensions

None.

NOTE: The RVA20 specification only considers extensions ratified in
2019.

=== RVA20S64 Profile

The RVA20S64 profile includes the supervisor components of privileged
architecture version 1.11.  This is the profile used by rich operating
system platforms.

The RVA20S64 mandatory base includes RVA20U64 unprivileged
instructions, except that ECALL in user mode causes a contained trap
to supervisor mode.

==== RVA20S64 Mandatory Extensions

- All RVA20U64 mandatory extensions
- Zifencei
- Ss1p11
- Sv39
- In addition to Sv39, the satp mode Bare must be supported.
- Main memory regions with both the cacheability and coherence PMAs must
  support hardware page-table reads.
  Such regions must additionally support hardware page-table writes if
  any harts support hardware page-table writes.
- stvec.MODE must be capable of holding the value 0 (Direct).
  stvec.BASE must be capable of holding any valid four-byte-aligned address.
- stval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, stval must be written with the faulting
  instruction.
- For any hpmcounter that is not read-only zero, the corresponding bit
  in scounteren must be writable.

==== RVA20S64 Supported Optional Extensions

- Sv48

NOTE: There are additional options and parameters in the privileged
architecture that should be detailed here.

==== RVA20S64 Unsupported Optional Extensions

- Q

==== RVA20S64 Incompatible Extensions

None.

=== RVA20M64 Profile

The RVA20M64 profile is defined to help provide compatibilty for
application-processor platforms that specify an M-mode execution
environment for portable software.

NOTE: Most OS platforms will have no code specified to run in M-mode,
instead accessing lower-level platform services via abstract
environment calls from supervisor mode.

NOTE: M-mode will often inherently include implementation-specific
features in addition to the profile requirements.

==== RVA20M64 Mandatory Extensions

- All RVA20S64 mandatory extensions, _except_ F, D, and misaligned loads
  and stores.
- Sm1p11
- mvendorid, marchid, and mimpid registers must be nonzero.
- mstatus.TVM, mstatus.TW, and mstatus.TSR must be writable.
- mtvec.MODE must be capable of holding the value 0 (Direct).
  mtvec.BASE must be capable of holding any valid four-byte-aligned address.
- medeleg bits 3, 8, 12, 13, and 15 must be writable.
- mideleg bits 1, 5, and 9 must be writable.  mideleg bits 3, 7, and 11
  must be read-only zero.
- For any mhpmcounter that is writable, the corresponding bit
  in mcounteren must be writable.
- mtval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, mtval must be written with the faulting
  instruction.
- PMP entries 0-3 must be implemented and must support modes OFF, NAPOT,
  and TOR, with a granularity of at most 4 KiB.

==== RVA20M64 Supported Optional Extensions

- All RVA20S64 supported optional extensions
- F
- D
- Misaligned loads and stores

NOTE: There are other options and parameters in the privileged
architecture that should be detailed here.

==== RVA20M64 Unsupported Optional Extensions

- All RVA20S64 unsupported optional extensions

==== RVA20M64 Incompatible Extensions

- All RVA20S64 incompatible extensions

== RVA22 Profiles

The RVA22 family of profiles are intended to be used for 64-bit
application processors running rich OS stacks.

NOTE: Only 64-bit is shown here, but should also include 32-bit
variant.

=== RVA22U64 Profile

The RVA22U64 profile represents the behavior of unprivileged code in
applications processors.

==== RVA22U64 Mandatory Extensions

- M
- A
- F
- D
- C
- Zicsr
- Zicntr
- Zihpm
- Zicbom
- Zicbop
- Zicboz
- Zihintpause
- Zba
- Zbb
- Zbs
- Misaligned loads and stores to main memory regions with both the
  cacheability and coherence PMAs must be supported.
- Main memory regions with both the cacheability and coherence PMAs must
  support instruction fetch, AMOArithmetic, and RsrvEventual.
- Reservation sets must be contiguous and at least 16 bytes and at most 128 bytes in size.
- Implementations are strongly recommended to raise illegal-instruction
  exceptions when attempting to execute unimplemented opcodes.

NOTE: Even when supported, misaligned loads and stores might execute
extremely slowly.  Standard software distributions should assume their
existence only for correctness, not for performance.

==== RVA22U64 Supported Optional Extensions

- Zbc   (un?)
- Zbkb  (un?)
- Zbkc  (un?)
- Zbkx  (un?)
- Zfh
- Zfhmin (mand?)
- Zk = { Zkn,Zkr,Zkt }
- Zkn = { Zbkb,Zbkc,Zbkx,Zkne,Zknd,Zknh }
- Zknd  (un?)
- Zkne  (un?)
- Zknh  (un?)
- Zkr   
- Zks = { Zbkb,Zbkc,Zbkx,Zbksed,Zbksh }
- Zksed (un?)
- Zksh  (un?)
- Zkt   (mand?)
- Zve32f (un?)
- Zve32x (un?)
- Zve64d (un?)
- Zve64f (un?)
- Zve64x (un?)
- V

NOTE: Might only have the larger groups as supported, and smaller
extension pieces as unsupported - marked (un?) above.

NOTE: Might make Zkt and/or Zfhmin mandatory - marked (mand?) above.

==== RVA22U64 Unsupported Optional Extensions

- Q
- Zifencei

NOTE: The execution environment must provide a means to synchronize writes to
instruction memory with instruction fetches, the implementation of which
likely relies on the Zifencei extension.
For example, RISC-V Linux supplies the `__riscv_flush_icache` system call and
a corresponding vDSO call.

==== RVA22U64 Incompatible Extensions

- Zfinx
- Zdinx
- Zhinx
- Zhinxmin

=== RVA22S64 Profile

The RVA22S64 profile includes the supervisor components of privileged
architecture version 1.12.

The RVA22S64 mandatory base includes RVA22U64 unprivileged
instructions, except that ECALL in user mode causes a contained trap
to supervisor mode.

==== RVA22S64 Mandatory Extensions

- All RVA22U64 mandatory extensions
- Zifencei
- Ss1p12
- Sv39
- Main memory regions with both the cacheability and coherence PMAs must
  support hardware page-table reads.
  Such regions must additionally support hardware page-table writes if
  any harts support hardware page-table writes.
- stvec.MODE must be capable of holding the value 0 (Direct).
  stvec.BASE must be capable of holding any valid four-byte-aligned address.
- stval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, stval must be written with the faulting
  instruction.
- sstatus.UBE must not be read-only 1.
- For any hpmcounter that is not read-only zero, the corresponding bit
  in scounteren must be writable.
- In addition to Sv39, the satp mode Bare must be supported.

If the hypervisor extension is implemented, the following are also mandatory:
- hstatus.VTVM, hstatus.VTW, and hstatus.VTSR must be writable.
- For any hpmcounter that is not read-only zero, the corresponding bit
  in hcounteren must be writable.
- htval and vstval must be written in all cases described above for stval.
- htval2 must be written with the faulting guest physical address in all
  circumstances permitted by the ISA.
- vstvec.MODE must be capable of holding the value 0 (Direct).
  vstvec.BASE must be capable of holding any valid four-byte-aligned address.
- All translation modes supported in satp must be supported in vsatp.
- For each supported virtual memory scheme SvNN supported in satp, the
  corresponding hgatp SvNNx4 mode must be supported.  The hgatp mode Bare
  must also be supported.

==== RVA22S64 Supported Optional Extensions

- All RVA22U64 supported optional extensions
- Hypervisor extension
- Sv48

NOTE: There are additional options and parameters in the privileged
architecture that should be detailed here.

==== RVA22S64 Unsupported Optional Extensions

- Q

==== RVA22S64 Incompatible Extensions

- All RVA22U64 incompatible extensions

=== RVA22M64 Profile

==== RVA22M64 Mandatory Extensions

- All RVA22S64 mandatory extensions, _except_ F, D, and misaligned loads
  and stores.
- Sm1p12
- mvendorid, marchid, and mimpid registers must be nonzero.
- mstatus.TVM, mstatus.TW, and mstatus.TSR must be writable.
- mstatus.MBE, mstatus.SBE, and mstatus.UBE must not be read-only 1.
- mtvec.MODE must be capable of holding the value 0 (Direct).
  mtvec.BASE must be capable of holding any valid four-byte-aligned address.
- medeleg bits 3, 8, 12, 13, and 15 must be writable.
- mideleg bits 1, 5, and 9 must be writable.  mideleg bits 3, 7, and 11
  must be read-only zero.
- For any mhpmcounter that is writable, the corresponding bits
  in mcounteren and mcountinhibit must be writable.
- mtval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, mtval must be written with the faulting
  instruction.
- PMP entries 0-3 must be implemented and must support modes OFF, NAPOT,
  and TOR, with a granularity of at most 4 KiB.

If the hypervisor extension is implemented, the following are also mandatory:
- medeleg bits 10, 20, 21, 22, and 23 must additionally be writable.
- mtval2 must be written with the faulting guest physical address in all
circumstances permitted by the ISA.

==== RVA22M64 Supported Optional Extensions

- All RVA22S64 supported optional extensions
- F
- D
- Misaligned loads and stores

NOTE: Consider making Zicbom supported-optional here to facilitate
trap & emulate, for systems that use some out-of-band mechanism?

NOTE: There are options and parameters in the privileged architecture
that should be detailed here.

==== RVA22M64 Unsupported Optional Extensions

- All RVA22S64 unsupported optional extensions

==== RVA22M64 Incompatible Extensions

- All RVA22S64 incompatible extensions

== Glossary of ISA Extensions

The following unprivileged ISA extensions are defined in Volume I
of the https://github.com/riscv/riscv-isa-manual[RISC-V Instruction Set Manual].

- M Extension for Integer Multiplication and Division
- A Extension for Atomic Memory Operations
- F Extension for Single-Precision Floating-Point
- D Extension for Double-Precision Floating-Point
- Q Extension for Quad-Precision Floating-Point
- C Extension for Compressed Instructions
- Zifencei Instruction-Fetch Synchronization Extension
- Zicsr Extension for Control and Status Register Access
- Zicntr Extension for Basic Performance Counters
- Zihintpause Pause Hint Extension
- Zfh Extension for Half-Precision Floating-Point
- Zfhmin Minimal Extension for Half-Precision Floating-Point
- Zfinx Extension for Single-Precision Floating-Point in x-registers
- Zdinx Extension for Double-Precision Floating-Point in x-registers
- Zhinx Extension for Half-Precision Floating-Point in x-registers
- Zhinxmin Minimal Extension for Half-Precision Floating-Point in x-registers

The following privileged ISA extensions are defined in Volume II
of the https://github.com/riscv/riscv-isa-manual[RISC-V Instruction Set Manual].

- Sv32 Page-based Virtual Memory Extension, 32-bit
- Sv39 Page-based Virtual Memory Extension, 39-bit
- Sv48 Page-based Virtual Memory Extension, 48-bit
- Hypervisor Extension
- Sm1p11, Machine Architecture v1.11
- Sm1p12, Machine Architecture v1.12
- Ss1p11, Supervisor Architecture v1.11
- Ss1p12, Supervisor Architecture v1.12

The following extensions have not yet been incorporated into the RISC-V
Instruction Set Manual; the hyperlinks lead to their separate specifications.

- https://github.com/riscv/riscv-bitmanip[Zba Address Computation Extension]
- https://github.com/riscv/riscv-bitmanip[Zbb Bit Manipulation Extension]
- https://github.com/riscv/riscv-bitmanip[Zbc Carryless Multiplication Extension]
- https://github.com/riscv/riscv-bitmanip[Zbs Single-Bit Manipulation Extension]
- https://github.com/riscv/riscv-crypto[Zbkb Extension for Bit Manipulation for Cryptography]
- https://github.com/riscv/riscv-crypto[Zbkc Extension for Carryless Multiplication for Cryptography]
- https://github.com/riscv/riscv-crypto[Zbkx Crossbar Permutation Extension]
- https://github.com/riscv/riscv-crypto[Zk Standard Scalar Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zkn NIST Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zknd AES Decryption Extension]
- https://github.com/riscv/riscv-crypto[Zkne AES Encryption Extension]
- https://github.com/riscv/riscv-crypto[Zknh SHA2 Hashing Extension]
- https://github.com/riscv/riscv-crypto[Zkr Entropy Source Extension]
- https://github.com/riscv/riscv-crypto[Zks ShangMi Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zksed SM4 Block Cypher Extension]
- https://github.com/riscv/riscv-crypto[Zksh SM3 Hashing Extension]
- https://github.com/riscv/riscv-crypto[Zkt Extension for Data-Independent Execution Latency]
- https://github.com/riscv/riscv-v-spec[V Extension for Vector Computation]
- https://github.com/riscv/riscv-v-spec[Zve32x Extension for Embedded Vector Computation (32-bit integer)]
- https://github.com/riscv/riscv-v-spec[Zve32f Extension for Embedded Vector Computation (32-bit integer, 32-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve32d Extension for Embedded Vector Computation (32-bit integer, 64-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve64x Extension for Embedded Vector Computation (64-bit integer)]
- https://github.com/riscv/riscv-v-spec[Zve64f Extension for Embedded Vector Computation (64-bit integer, 32-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve64d Extension for Embedded Vector Computation (64-bit integer, 64-bit FP)]
- https://github.com/riscv/riscv-CMOs[Zicbom Extension for Cache-Block Management]
- https://github.com/riscv/riscv-CMOs[Zicbop Extension for Cache-Block Prefetching]
- https://github.com/riscv/riscv-CMOs[Zicboz Extension for Cache-Block Zeroing]
