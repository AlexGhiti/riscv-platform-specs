[[riscv-doc-template]]
:description: Short, text description of spectâ€¦
:company: RISC-V
:revdate: January 10, 2022
:revnumber: 0.1-draft
:revremark: This document is in Discussion state.  Change should be expected.
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:imagesdir: images
:title-logo-image: image:riscv-images/risc-v_logo.png[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
:WaveDromEditorApp: wavedrom-cli
:imagesoutdir: images
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:sectnumlevels: 5
:toclevels: 5
:toc: left
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short
:numbered:
:stem: latexmath
:le: &#8804;
:ge: &#8805;
:ne: &#8800;
:approx: &#8776;
:inf: &#8734;

:sectnums!:

= RISC-V Profiles

//: This is the Preable

[WARNING]
.This document is in the link:http://riscv.org/spec-state[Discussion state]
====
Assume everything can change. This document is not complete yet and was 
created only for the purpose of conversation outside of the document.

*This is only an initial proposal and is likely to change substantially if it is standardized.*
====

:sectnums:

== Introduction

RISC-V was designed to provide a highly modular and extensible
instruction set, and includes a large and growing set of standard
extensions.  In addition, users may add their own custom
extensions. This flexibility can be used to highly optimize a
specialized design by including only the exact set of ISA features
required for an application, but the same flexibility also leads to a
combinatorial explosion in possible ISA choices.  Profiles specify a
much smaller common set of ISA choices that capture the most value for
most users, and which thereby enable the software community to focus
resources on building a rich software ecosystem.

NOTE: Another pragmatic concern is the long and unwieldy ISA strings
required to encode common sets of extensions, which will continue to
grow as new extensions are defined.

Each profile is built on a standard base ISA plus a set of mandatory
ISA extensions, and provides a small set of standard ISA options to
extend the mandatory components.  Profiles provide a convenient
shorthand for describing the ISA portions of hardware and software
platforms, and also guide the development of common software
toolchains shared by different platforms that use the same profile.
The intent is that the software ecosystem focus on supporting the
profiles' mandatory base and standard options, instead of attempting
to support every possible combination of individual extensions.
Similarly, hardware vendors should aim to structure their offerings
around standard profiles to increase the likelihood their designs will
have mainstream software support.

NOTE: Profiles are not intended to prohibit the use of combinations of
individual ISA extensions or the addition of custom extensions, which
can continue to be used for more specialized applications albeit
without the expectation of widespread software support.

As RISC-V evolves over time, the set of ISA features will grow, and
new platforms will be added that may need different profiles.  To
manage this evolution, RISC-V is adopting a model of regular annual
releases of new ISA profiles, following an ISA roadmap managed by the
RISC-V Technical Steering Committee.

The architecture profiles will also be used for branding and to
advertise compatibility with the RISC-V standard.

This document describes the general structure of RISC-V architecture
profiles and also the specifics of the first two families of
architecture profiles for application processors: RVA20 and RVA22.

NOTE: Other profiles are under development: RVI20 for basic RISC-V
unprivileged software compatibility, and RVM20 and RVM22 for
microcontroller platforms and these will be added in a future version
of this document.

== Profiles versus Platforms

Profiles only describe ISA features, not a complete execution
environment.

A _software_ _platform_ is a specification for an execution
environment, in which software targeted for that software platform can
run.

A _hardware_ _platform_ is a specification for a hardware system
(which can be viewed as a physical realization of an execution
environment).

Both software and hardware platforms include specifications for many
features beyond details of the ISA used by RISC-V harts in the
platform (e.g., boot process, calling convention, behavior of
environment calls, discovery mechanism, presence of certain
memory-mapped hardware devices, etc.).  Architecture profiles factor
out ISA-specific definitions from platform definitions to allow ISA
profiles to be reused across different platforms, and to be used by
tools (e.g., compilers) that are common across many different
platforms.

A platform can add additional constraints on top of those in a
profile.  For example, mandating an extension that is a standard
option in the underlying profile, or constraining some
implementation-specific parameter in the profile to lie within a
certain range.

A platform cannot remove constraints from a profile.

NOTE: A new profile should be proposed if existing profiles do not
match the needs of a new platform.

== Components of a Profile

=== Profile Family

Every profile is a member of a _profile_ _family_.  A profile family
is a set of profiles that are designed for the same applications and
that share the same base ISA but which vary in highest-supported
privilege mode.  The initial three types of family are:

- generic unprivileged instructions (I)
- microcontrollers for embedded systems (M)
- application processors running rich operating systems (A)

A profile family may be updated no more than annually, and the release
calendar year is treated as part of the profile family name.

More profile families may be added over time.

Each profile family is described in more detail below.

=== Profile Privilege Mode

RISC-V has a layered architecture supporting multiple privilege modes,
and most RISC-V platforms support more than one privilege mode.
Software is usually written assuming a particular privilege mode
during execution.  For example, application code is written assuming
it will be run in user mode, and kernel code is written assuming it
will be run in supervisor mode.

NOTE: Software can be run in a mode different than the one for which
it was written. For example, privileged code using privileged ISA
features can be run in a user-mode execution environment, but will
then cause traps into the enclosing execution environment when
privileged instructions are executed.  This behavior might be
exploited, for example, to emulate a privileged execution environment
using a user-mode execution environment.

In general, available instructions vary by privilege mode, and the
behavior of RISC-V instructions can depend on the current privilege
mode.  For this reason, there are separate profiles for each
privileged mode that a profile family supports.

A profile may specify that certain conditions will cause a requested
trap (such as an `ecall` made in the highest-supported privilege mode)
or fatal trap to the enclosing execution environment.

NOTE: A profile does not constrain how invisible traps to a more
privileged mode are used to emulate profile features.  In general, a
profile can be implemented by an execution environment using any
hardware or software technique that provides compatible functionality,
up to and including pure software emulation.

The profile for a privilege mode describes the ISA features for an
execution environment that has the eponymous privilege mode as the
most-privileged mode available, but also includes all supported
lower-privilege modes.  For example, an S-mode profile includes U-mode
as well as S-mode and describes the behavior of instructions when
running in different modes in an S-mode execution environment, such as
how an `ecall` instruction in U-mode causes a contained trap into an
S-mode handler whereas an `ecall` in S-mode causes a requested trap
out to the execution environment.

A more-privileged profile can always support running software to
implement a less-privileged profile from the same profile family.  For
example, a platform supporting the S-mode profile can run a
supervisor-mode operating system that provides user-mode execution
environments supporting the U-mode profile.

NOTE: Instructions in a U-mode profile, which are all executed in user
mode, have potentially different behaviors than instructions executed
in user mode in an S-mode profile.  For this reason, a U-mode profile
cannot be considered a subset of an S-mode profile.

=== Profile ISA Features

An architecture profile has a mandatory base instruction set (RV32I or
RV64I).

NOTE: RV32I and RV64I are the only currently ratified base ISAs.

In addition, the profile categorizes all ratified ISA extensions for
that base ISA into four categories:

. Mandatory
. Supported Optional
. Unsupported Optional
. Incompatible

As the name implies, _Mandatory_ _ISA_ _extensions_ are a required
part of the profile.  Implementations of the profile must provide
these.  The combination of the profile base ISA plus the mandatory ISA
extensions are termed the profile _mandates_, and software using the
profile can assume these always exist.

_Supported_ _Optional_ extensions (also known as _supported_
_options_), are those that are optional, but which are expected to be
generally supported by the software ecosystem for this profile.

NOTE: The level of "support" for Supported Optional extension will
likely vary greatly among different software components supporting a
profile, but at the bare minimum tools or runtimes that are claiming
compatibility with the profile must not report errors or warnings if
supported options are present.

_Unsupported_ _Optional_ _Extensions_ are those that are optional, but
which are not expected to be generally supported by the software
ecosystem.

NOTE: Software components claiming to support a profile are not
expected to be able to support these extensions, and may error or
report warnings if they are present.

_Incompatible_ _extensions_ are those that conflict with the base or
optional extensions.  Software can assume these extensions are not
present.

The profile mandates and supported options describe the set of ISA
features the software ecosystem for that profile is expected to
support, and the granularity of that support (i.e., subsets of a
supported option are not a supported option).

All components of a ratified profile must themselves have been
ratified.

NOTE: Extensions that are ratified after a given profile is released
are effectively either Unsupported Optional or Incompatible for that
profile.  A later release of a profile family may choose to
include the feature as Mandatory or Supported Optional.

Platforms may provide a discovery mechanism to determine what optional
extensions are present.

=== Profile Naming Convention

A profile name is a string comprised of, in order:

. prefix RV for RISC-V
. a specific profile family string (I, M, or A)
. a numeric string giving the first complete calendar year for which
the profile is ratified, represented as number of years after year
2000 (i.e., 20 for profiles built on specifications ratified during 2019)
. a privilege mode (U, S, M)
. a base ISA specifier (32, 64)

The initial profiles based on specifications ratified in 2019 are:

- RVI20U32 basic unprivileged instructions for RV32I
- RVI20U64 basic unprivileged instructions for RV64I
- RVM20U32, RVM20S32, RVM20M32 profiles for microcontrollers based on RV32I
- RVM20U64, RVM20S64, RVM20M64 profiles for microcontrollers based on RV64I
- RVA20U64, RVA20S64 64-bit application-processor profiles

NOTE: This document currently only includes the RVAx64 profiles, which
are the first to be defined.  The others will be added later.

== RVA20 Profiles

The RVA20 profiles are intended to be used for application processors
running rich OS stacks.  Only user-mode (RVA20U64) and supervisor-mode
(RVA20S64) profiles are specified in this family.

NOTE: There is no machine-mode profile defined.  A machine-mode profile
for application processors would only be used in specifying platforms
for portable machine-mode software. Given the relatively low volume of
portable M-mode software, the wide variety of potential M-mode code,
and the very specific needs of each type of M-mode software, we assume
each portable M-mode software ecosystem would specify individual ISA
requirements as part of their M-mode platform specification.

NOTE: Only 64-bit application processor profiles are currently
defined.  It would be possible to also define very similar 32-bit
variants.

=== RVA20U64 Profile

The RVA20U64 profile specifies the ISA features available to
user-mode execution environments in 64-bit applications processors.
This is the most important profile within the application processor
family in terms of the amount of software that targets this profile.

RVA20U64 has no supported options.

==== RVA20U64 Mandatory Base

RV64I is the mandatory base ISA for RVA20U64.

==== RVA20U64 Mandatory Extensions

- *M* Integer multiplication and divison.
- *A* Atomic instructions.
- *F* Single-precision floating-point instructions.
- *D* Double-precision floating-point instructions.
- *C* Compressed Instructions.
- *Zicsr*  CSR instructions.  These are implied by presence of F.
- *Zicntr* Base counters and timers.
- *Zihpm* Hardware performance counters.
- Main memory regions with both the cacheability and coherence PMAs must
  support instruction fetch, AMOArithmetic, and RsrvEventual.
- Reservation sets must be contiguous and at least 16 bytes and at most 128 bytes in size.
- Misaligned loads and stores to main memory regions with both the
  cacheability and coherence PMAs must be supported.

NOTE: Even when supported, misaligned loads and stores might execute
extremely slowly.  Standard software distributions should assume their
existence only for correctness, not for performance.

==== RVA20U64 Supported Optional Extensions

None.

==== RVA20U64 Unsupported Optional Extensions

- *Q* Quad-precision floating-point instructions.

NOTE: Quad-precision floating-point is unlikely to be implemented in
hardware.

- *Zifencei* Instruction-fetch fence instruction.

NOTE: Zifencei is not classed as supported optional in the user-mode
profile because it is not sufficient by itself to produce the desired
effect in a multiprogrammed multiprocessor environment without OS
support, and so the instruction cache flush should always be performed
using an OS call rather than using the `fence.i` instruction.  `fence.i`
semantics can be expensive to implement for some hardware memory
hierarchy designs, and so alternative non-standard instruction-cache
coherence mechanisms can be used behind the OS abstraction.  A
separate extension is being developed for more general and efficient
instruction cache coherence.

NOTE: The execution environment must provide a means to synchronize writes to
instruction memory with instruction fetches, the implementation of which
likely relies on the Zifencei extension.
For example, RISC-V Linux supplies the `__riscv_flush_icache` system call and
a corresponding vDSO call.

==== RVA20U64 Incompatible Extensions

None.

NOTE: The RVA20 specification only categorizes extensions ratified in
2019.

==== RVA20U64 Recommendations

Recommendations are not strictly mandated but are included to guide
implementers making design choices.

Implementations are strongly recommended to raise illegal-instruction
exceptions on attempts to execute unimplemented opcodes.

=== RVA20S64 Profile

The RVA20S64 profile specifies the ISA features available to a
supervisor-mode execution environment in 64-bit applications
processors.  RVA20S64 is based on privileged architecture version
1.11.

RVA20S64 has only one supported option (Sv48).

==== RVA20S64 Mandatory Base

RV64I is the mandatory base ISA for RVA20S64.

==== RVA20S64 Mandatory Extensions

The following unprivileged extensions are mandatory:

- The RVA20S64 mandatory base includes all the mandatory unprivileged
instructions in RVA20U64, except that `ecall` in user mode causes a
contained trap to supervisor mode.

- *Zifencei*  Instruction-Fetch Fence.

NOTE: Zifencei is mandated as it is the only standard way to support
instruction-cache coherence in RVA20 application processors.  A new
instruction-cache coherence mechanism is under development which might
be added as an option in the future.

The following privileged extensions are mandatory:

- *Ss1p11*  Privileged Architecture version 1.11.

- *Sv39* Page-Based 39-bit Virtual-Memory System.

- In addition to Sv39, the `satp` mode Bare must be supported.

- Main memory regions with both the cacheability and coherence PMAs must
  support hardware page-table reads.
  Such regions must additionally support hardware page-table writes if
  any harts support hardware page-table writes.

- `stvec.MODE` must be capable of holding the value 0 (Direct).  When
  `stvec.MODE=Direct`, `stvec.BASE` must be capable of holding any
  valid four-byte-aligned address.

- `stval` must be written with the faulting virtual address for load,
  store, and instruction page-fault, access-fault, and misaligned
  exceptions, and for breakpoint exceptions other than those caused by
  execution of the `ebreak` or `c.ebreak` instructions.  For
  illegal-instruction exceptions, `stval` must be written with the
  faulting instruction.

- For any `hpmcounter` that is not read-only zero, the corresponding bit
  in `scounteren` must be writable.

==== RVA20S64 Supported Optional Extensions

RVA20S64 has no unprivileged optional extensions.

The following are privileged optional extensions:

- *Sv48* Page-Based 48-bit Virtual-Memory System.

NOTE: There are additional options and parameters in the privileged
architecture that should be detailed here.

==== RVA20S64 Unsupported Optional Extensions

The following unprivileged extensions are unsupported:

- *Q*  Quad-Precision Floating-Point.

- *N* User-Level Interrupts.

NOTE: The unprivileged N extension for user-level interrupts has _not_
been ratified, but the ratified privileged architecture v1.11 text
refers to user-level interrupts.

The following privileged extensions are unsupported:

- *sstatus.UXL!=64*  Different User-Mode XLEN.

NOTE: This extension is not expected to be widely used.

- *stvec.MODE=Vectored*  Hardware Trap Vectoring.

NOTE: Hardware vectoring of exception/interrupt traps is not generally
used by rich operating systems.




==== RVA20S64 Incompatible Extensions

There are no incompatible unprivileged extensions.

The following are incompatible privileged extensions:

- *IALIGN!=16* Masking of `sepc[1]` bit.

NOTE: Increasing IALIGN to 32 by disabling compressed instructions is
incompatible as the RVA20S64 profile mandates compressed instruction
support.  Systems supporting dynamic switching must turn on compressed
instruction support (e.g., by setting the `misa.c` bit) before
creating a supervisor-mode execution environment following the
RVA20S64 profile.

////
OLD TEXT TO BE IGNORED

=== RVA20M64 Profile 

The RVA20M64 profile is defined to help provide compatibilty for
application-processor platforms that specify an M-mode execution
environment for portable software.

NOTE: Most OS platforms will have no code specified to run in M-mode,
instead accessing lower-level platform services via abstract
environment calls from supervisor mode.

NOTE: M-mode will often inherently include implementation-specific
features in addition to the profile requirements.

==== RVA20M64 Mandatory Extensions

- All RVA20S64 mandatory extensions, _except_ F, D, and misaligned loads
  and stores.
- Sm1p11
- mvendorid, marchid, and mimpid registers must be nonzero.
- mstatus.TVM, mstatus.TW, and mstatus.TSR must be writable.
- mtvec.MODE must be capable of holding the value 0 (Direct).
  When mtvec.MODE=Direct,
  mtvec.BASE must be capable of holding any valid four-byte-aligned address.
- medeleg bits 3, 8, 12, 13, and 15 must be writable.
- mideleg bits 1, 5, and 9 must be writable.  mideleg bits 3, 7, and 11
  must be read-only zero.
- For any mhpmcounter that is writable, the corresponding bit
  in mcounteren must be writable.
- mtval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, mtval must be written with the faulting
  instruction.
- PMP entries 0-3 must be implemented and must support modes OFF, NAPOT,
  and TOR, with a granularity of at most 4 KiB.

==== RVA20M64 Supported Optional Extensions

- All RVA20S64 supported optional extensions
- F
- D
- Misaligned loads and stores

NOTE: There are other options and parameters in the privileged
architecture that should be detailed here.

==== RVA20M64 Unsupported Optional Extensions

- All RVA20S64 unsupported optional extensions

==== RVA20M64 Incompatible Extensions

- All RVA20S64 incompatible extensions

////

== RVA22 Profiles

The RVA22 family of profiles are intended to be used for 64-bit
application processors running rich OS stacks.

NOTE: Only 64-bit is shown here, but should also include 32-bit
variant.

=== RVA22U64 Profile

The RVA22U64 profile represents the behavior of unprivileged code in
applications processors.

==== RVA22U64 Mandatory Extensions

- M
- A
- F
- D
- C
- Zicsr
- Zicntr
- Zihpm
- Zicbom
- Zicbop
- Zicboz
- Zihintpause
- Zba
- Zbb
- Zbs
- Misaligned loads and stores to main memory regions with both the
  cacheability and coherence PMAs must be supported.
- Main memory regions with both the cacheability and coherence PMAs must
  support instruction fetch, AMOArithmetic, and RsrvEventual.
- Reservation sets must be contiguous and at least 16 bytes and at most 128 bytes in size.
- Implementations are strongly recommended to raise illegal-instruction
  exceptions when attempting to execute unimplemented opcodes.

NOTE: Even when supported, misaligned loads and stores might execute
extremely slowly.  Standard software distributions should assume their
existence only for correctness, not for performance.

==== RVA22U64 Supported Optional Extensions

- Zbc   (un?)
- Zbkb  (un?)
- Zbkc  (un?)
- Zbkx  (un?)
- Zfh
- Zfhmin (mand?)
- Zk = { Zkn,Zkr,Zkt }
- Zkn = { Zbkb,Zbkc,Zbkx,Zkne,Zknd,Zknh }
- Zknd  (un?)
- Zkne  (un?)
- Zknh  (un?)
- Zkr   
- Zks = { Zbkb,Zbkc,Zbkx,Zbksed,Zbksh }
- Zksed (un?)
- Zksh  (un?)
- Zkt   (mand?)
- Zve32f (un?)
- Zve32x (un?)
- Zve64d (un?)
- Zve64f (un?)
- Zve64x (un?)
- V

NOTE: Might only have the larger groups as supported, and smaller
extension pieces as unsupported - marked (un?) above.

NOTE: Might make Zkt and/or Zfhmin mandatory - marked (mand?) above.

==== RVA22U64 Unsupported Optional Extensions

- Q
- Zifencei

NOTE: The execution environment must provide a means to synchronize writes to
instruction memory with instruction fetches, the implementation of which
likely relies on the Zifencei extension.
For example, RISC-V Linux supplies the `__riscv_flush_icache` system call and
a corresponding vDSO call.

==== RVA22U64 Incompatible Extensions

- Zfinx
- Zdinx
- Zhinx
- Zhinxmin

=== RVA22S64 Profile

The RVA22S64 profile includes the supervisor components of privileged
architecture version 1.12.

The RVA22S64 mandatory base includes RVA22U64 unprivileged
instructions, except that ECALL in user mode causes a contained trap
to supervisor mode.

==== RVA22S64 Mandatory Extensions

- All RVA22U64 mandatory extensions
- Zifencei
- Ss1p12
- Sv39
- Main memory regions with both the cacheability and coherence PMAs must
  support hardware page-table reads.
  Such regions must additionally support hardware page-table writes if
  any harts support hardware page-table writes.
- stvec.MODE must be capable of holding the value 0 (Direct).
  When stvec.MODE=Direct,
  stvec.BASE must be capable of holding any valid four-byte-aligned address.
- stval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, stval must be written with the faulting
  instruction.
- sstatus.UBE must not be read-only 1.
- For any hpmcounter that is not read-only zero, the corresponding bit
  in scounteren must be writable.
- In addition to Sv39, the satp mode Bare must be supported.

If the hypervisor extension is implemented, the following are also mandatory:
- hstatus.VTVM, hstatus.VTW, and hstatus.VTSR must be writable.
- For any hpmcounter that is not read-only zero, the corresponding bit
  in hcounteren must be writable.
- htval and vstval must be written in all cases described above for stval.
- htval2 must be written with the faulting guest physical address in all
  circumstances permitted by the ISA.
- vstvec.MODE must be capable of holding the value 0 (Direct).
  When vstvec.MODE=Direct,
  vstvec.BASE must be capable of holding any valid four-byte-aligned address.
- All translation modes supported in satp must be supported in vsatp.
- For each supported virtual memory scheme SvNN supported in satp, the
  corresponding hgatp SvNNx4 mode must be supported.  The hgatp mode Bare
  must also be supported.

==== RVA22S64 Supported Optional Extensions

- All RVA22U64 supported optional extensions
- Hypervisor extension
- Sv48

NOTE: There are additional options and parameters in the privileged
architecture that should be detailed here.

==== RVA22S64 Unsupported Optional Extensions

- Q

==== RVA22S64 Incompatible Extensions

- All RVA22U64 incompatible extensions

=== RVA22M64 Profile

==== RVA22M64 Mandatory Extensions

- All RVA22S64 mandatory extensions, _except_ F, D, and misaligned loads
  and stores.
- Sm1p12
- mvendorid, marchid, and mimpid registers must be nonzero.
- mstatus.TVM, mstatus.TW, and mstatus.TSR must be writable.
- mstatus.MBE, mstatus.SBE, and mstatus.UBE must not be read-only 1.
- mtvec.MODE must be capable of holding the value 0 (Direct).
  When mtvec.MODE=Direct,
  mtvec.BASE must be capable of holding any valid four-byte-aligned address.
- medeleg bits 3, 8, 12, 13, and 15 must be writable.
- mideleg bits 1, 5, and 9 must be writable.  mideleg bits 3, 7, and 11
  must be read-only zero.
- For any mhpmcounter that is writable, the corresponding bits
  in mcounteren and mcountinhibit must be writable.
- mtval must be written with the faulting virtual address for load, store, and
  instruction page-fault, access-fault, and misaligned exceptions, and for
  breakpoint exceptions other than those caused by execution of the EBREAK or
  C.EBREAK instructions.
  For illegal-instruction exceptions, mtval must be written with the faulting
  instruction.
- PMP entries 0-3 must be implemented and must support modes OFF, NAPOT,
  and TOR, with a granularity of at most 4 KiB.

If the hypervisor extension is implemented, the following are also mandatory:
- medeleg bits 10, 20, 21, 22, and 23 must additionally be writable.
- mtval2 must be written with the faulting guest physical address in all
circumstances permitted by the ISA.

==== RVA22M64 Supported Optional Extensions

- All RVA22S64 supported optional extensions
- F
- D
- Misaligned loads and stores

NOTE: Consider making Zicbom supported-optional here to facilitate
trap & emulate, for systems that use some out-of-band mechanism?

NOTE: There are options and parameters in the privileged architecture
that should be detailed here.

==== RVA22M64 Unsupported Optional Extensions

- All RVA22S64 unsupported optional extensions

==== RVA22M64 Incompatible Extensions

- All RVA22S64 incompatible extensions

== Glossary of ISA Extensions

The following unprivileged ISA extensions are defined in Volume I
of the https://github.com/riscv/riscv-isa-manual[RISC-V Instruction Set Manual].

- M Extension for Integer Multiplication and Division
- A Extension for Atomic Memory Operations
- F Extension for Single-Precision Floating-Point
- D Extension for Double-Precision Floating-Point
- Q Extension for Quad-Precision Floating-Point
- C Extension for Compressed Instructions
- Zifencei Instruction-Fetch Synchronization Extension
- Zicsr Extension for Control and Status Register Access
- Zicntr Extension for Basic Performance Counters
- Zihintpause Pause Hint Extension
- Zfh Extension for Half-Precision Floating-Point
- Zfhmin Minimal Extension for Half-Precision Floating-Point
- Zfinx Extension for Single-Precision Floating-Point in x-registers
- Zdinx Extension for Double-Precision Floating-Point in x-registers
- Zhinx Extension for Half-Precision Floating-Point in x-registers
- Zhinxmin Minimal Extension for Half-Precision Floating-Point in x-registers

The following privileged ISA extensions are defined in Volume II
of the https://github.com/riscv/riscv-isa-manual[RISC-V Instruction Set Manual].

- Sv32 Page-based Virtual Memory Extension, 32-bit
- Sv39 Page-based Virtual Memory Extension, 39-bit
- Sv48 Page-based Virtual Memory Extension, 48-bit
- Hypervisor Extension
- Sm1p11, Machine Architecture v1.11
- Sm1p12, Machine Architecture v1.12
- Ss1p11, Supervisor Architecture v1.11
- Ss1p12, Supervisor Architecture v1.12

The following extensions have not yet been incorporated into the RISC-V
Instruction Set Manual; the hyperlinks lead to their separate specifications.

- https://github.com/riscv/riscv-bitmanip[Zba Address Computation Extension]
- https://github.com/riscv/riscv-bitmanip[Zbb Bit Manipulation Extension]
- https://github.com/riscv/riscv-bitmanip[Zbc Carryless Multiplication Extension]
- https://github.com/riscv/riscv-bitmanip[Zbs Single-Bit Manipulation Extension]
- https://github.com/riscv/riscv-crypto[Zbkb Extension for Bit Manipulation for Cryptography]
- https://github.com/riscv/riscv-crypto[Zbkc Extension for Carryless Multiplication for Cryptography]
- https://github.com/riscv/riscv-crypto[Zbkx Crossbar Permutation Extension]
- https://github.com/riscv/riscv-crypto[Zk Standard Scalar Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zkn NIST Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zknd AES Decryption Extension]
- https://github.com/riscv/riscv-crypto[Zkne AES Encryption Extension]
- https://github.com/riscv/riscv-crypto[Zknh SHA2 Hashing Extension]
- https://github.com/riscv/riscv-crypto[Zkr Entropy Source Extension]
- https://github.com/riscv/riscv-crypto[Zks ShangMi Cryptography Extension]
- https://github.com/riscv/riscv-crypto[Zksed SM4 Block Cypher Extension]
- https://github.com/riscv/riscv-crypto[Zksh SM3 Hashing Extension]
- https://github.com/riscv/riscv-crypto[Zkt Extension for Data-Independent Execution Latency]
- https://github.com/riscv/riscv-v-spec[V Extension for Vector Computation]
- https://github.com/riscv/riscv-v-spec[Zve32x Extension for Embedded Vector Computation (32-bit integer)]
- https://github.com/riscv/riscv-v-spec[Zve32f Extension for Embedded Vector Computation (32-bit integer, 32-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve32d Extension for Embedded Vector Computation (32-bit integer, 64-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve64x Extension for Embedded Vector Computation (64-bit integer)]
- https://github.com/riscv/riscv-v-spec[Zve64f Extension for Embedded Vector Computation (64-bit integer, 32-bit FP)]
- https://github.com/riscv/riscv-v-spec[Zve64d Extension for Embedded Vector Computation (64-bit integer, 64-bit FP)]
- https://github.com/riscv/riscv-CMOs[Zicbom Extension for Cache-Block Management]
- https://github.com/riscv/riscv-CMOs[Zicbop Extension for Cache-Block Prefetching]
- https://github.com/riscv/riscv-CMOs[Zicboz Extension for Cache-Block Zeroing]
